C++ Notes

Files:
	ofstream - output file stream
		ofstream outputFile("file.txt");
		outputFile << "Write to file just like cout";
	ifstream - input files stream
		ifstream inputFile;
			inputFile.open("file.txt");
			inputFile.open("C:\\data\\file.txt"); - extra backslash to represent string literal backslash
			inputFile.close();
			inputFile >> someString; - reads string from next read position, each string seperated by whitespace (space or newline)
			int value; inFile >> value; - converts number in file from string to number
			while (inFile >> value) - read to end of file
			if (inFile) {something} else {error} - test for file open errors
				if (infile.fail()) {error} else {something} - alternative to above
	fstream - file stream

C-strings - in older versions of C++
	strObject.c_str() - returns string stored in strObject as a null-terminated C-string
		Example: inFile.open(filename.c_str());

Reference variables as parameters
	example: timesTwo(int &num) { num*=2; }
		if int num = 4, then method(num) == 8

Two or more functions may have the same name, as long as their parameter lists are different.
	example: int square(int); double square(double);
	example: int square(int); int square(int, int); int square(int, double);

Range-based for loop:
	example - int numbers[] = {3,6,9};
				for (int val : numbers) { cout << val << endl; }

STL (Standard Template Library)
	data types defined in STL commonly called containers, because they store and organize data
		2 types
			sequence containers
				organizes data in a sequential fashion, similar to an array
			associative containers
				organizes data with keys, which allow rapid, random access to elements stored in container

	STL vector
		#include <vector> (must have using namespace std;)
			vector<int> numbers;
			vector<int> numbers(10); to define starting size
			vector<int> numbers(10, 2); to define starting size of 10, each element initialized to 2
			vector<int> set2(set1); initializes set2 by copying set 1 to it
			vector<int> numbers { 10, 20, 30, 40 }; initializes vector with list of values
				no need for equals sign like array: int numbers[] = { 10, 20, 30, 40 };
				numbers[i] can be replaced with new value
			Rang-based for loops is same as array:
				vector<int> numbers { 3, 6, 9};
					for (int val : numbers) { cout << val << endl; }
			push_back
				numbers.push_back(25); puts 26 in last element, or adds as new element if full
			pop_back
				numbers.pop_back(); removes the last element
			clear
				numbers.clear(); clears all elements
			empty
				if (numbers.empty()) determines if vector is empty
			size
				x = numbers.size(); x = size of vector
			at
				x = numbers.at(5); x = the value of the 6th element (an array would be numbers[5])
			reverse
				numbers.reverse(); reverses the order of elements
			resize(elements, value)
				numbers.resize(5, 1); increases size by 5 and initializes the new elements to 1
			swap(vector2)
				set1.swap(set2); swaps contents of set1 with set2

		holds a sequence of values, or elements
		stores its elements in contiguous memory locations
		you can use array subscript operator [] to read individual elements in the vector
			cannot use it to access element that does not yet exist

		Advantages over arrays:
			You don't have to declare the number of elements it will have
			If you add a value to a vector that's already full, it will automatically increase size
			Vectors can report the number of elements they contain

Searching and Sorting Arrays
	Linear Search
		Also called Sequential Search
		Searches the array from beginning to end
		Simple, but inefficient
	Binary Search
		Array must be sorted first
		Same as GuessTheNumber game
	Bubble Sort
		inefficient for large arrays
		void bubbleSort(int arr[],int size){ 
		   bool swap; int temp; 
		   do{ 
		      swap = false; 
		      for (int i = 0; i < (size − 1); i++) { 
		         if (arr[i] > arr[i + 1]) { 
		             temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; swap = true;
		         } 
		      } 
		   } while (swap); 
		}

	Selection Sort
		more efficient for larger arrays
		void selectionSort(int arr[],int size) { 
	       int start, minIndex, minVal; 
	       for (start = 0; start < (size − 1); start++) { 
	           minIndex = start; minVal = arr[start]; 
	           for(int i = start + 1; i < size; i++) { 
	               if (arr[i] < minVal) { 
	                   minVal = arr[i]; 
	                   minIndex = i; 
	               } 
	           } 
	           arr[minIndex] = arr[start]; arr[start] = minVal; 
	       } 
	    } 

Pointers
	Getting the address of a variable
		char: 1 byte
		short: 2 bytes
		int, long, float: 4 bytes
		double: 8 bytes
	A variables address is the address of first byte allocated to it
		example: int num = 25; &num = address of num, in hexadecimal
	Do not confuse with reference variables

	Pointer Variables, or just pointers
		designed to hold memory addresses
		indirectly manipulate data stored in other variables

	Defining pointer variables:
		int *ptr;	int means it can hold the address of an int variable
			the above means "ptr is a pointer to an int"
			could also be written as int* ptr; to make it clear that it's a pointer rather than int

		Always define pointer by initializing with valid memory address
			nullptr - points to address 0
				int *ptr = nullptr;
					with older, non-C++11-compliant compilers, use 0 or NULL

		* is an indirection operator. It dereferences the pointer
			You are working, not with the pointer variable itself, but with the item it points to

		an array name is really a pointer to the first address of the array
			arr[i] == *(arr + i)

		Cannot multiply or divide pointers

	Only use pointers with delete that were previously used with new

	Smart Pointers
		arrSelectSort
		showArrPtr
		showArray


