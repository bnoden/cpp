C++ Notes

Files:
	ofstream - output file stream
		ofstream outputFile("file.txt");
		outputFile << "Write to file just like cout";
	ifstream - input files stream
		ifstream inputFile;
			inputFile.open("file.txt");
			inputFile.open("C:\\data\\file.txt"); - extra backslash to represent string literal backslash
			inputFile.close();
			inputFile >> someString; - reads string from next read position, each string seperated by whitespace (space or newline)
			int value; inFile >> value; - converts number in file from string to number
			while (inFile >> value) - read to end of file
			if (inFile) {something} else {error} - test for file open errors
				if (infile.fail()) {error} else {something} - alternative to above
	fstream - file stream

C-strings - in older versions of C++
	strObject.c_str() - returns string stored in strObject as a null-terminated C-string
		Example: inFile.open(filename.c_str());

Reference variables as parameters
	example: timesTwo(int &num) { num*=2; }
		if int num = 4, then method(num) == 8

Two or more functions may have the same name, as long as their parameter lists are different.
	example: int square(int); double square(double);
	example: int square(int); int square(int, int); int square(int, double);

Range-based for loop:
	example - int numbers[] = {3,6,9};
				for (int val : numbers) { cout << val << endl; }

STL (Standard Template Library)
	data types defined in STL commonly called containers, because they store and organize data
		2 types
			sequence containers
				organizes data in a sequential fashion, similar to an array
			associative containers
				organizes data with keys, which allow rapid, random access to elements stored in container

	STL vector
		#include <vector> (must have using namespace std;)
			vector<int> numbers;
			vector<int> numbers(10); to define starting size
			vector<int> numbers(10, 2); to define starting size of 10, each element initialized to 2
			vector<int> set2(set1); initializes set2 by copying set 1 to it
			vector<int> numbers { 10, 20, 30, 40 }; initializes vector with list of values
				no need for equals sign like array: int numbers[] = { 10, 20, 30, 40 };
				numbers[i] can be replaced with new value
			Rang-based for loops is same as array:
				vector<int> numbers { 3, 6, 9};
					for (int val : numbers) { cout << val << endl; }
			push_back
				numbers.push_back(25); puts 26 in last element, or adds as new element if full
			pop_back
				numbers.pop_back(); removes the last element
			clear
				numbers.clear(); clears all elements
			empty
				if (numbers.empty()) determines if vector is empty
			size
				x = numbers.size(); x = size of vector
			at
				x = numbers.at(5); x = the value of the 6th element (an array would be numbers[5])
			reverse
				numbers.reverse(); reverses the order of elements
			resize(elements, value)
				numbers.resize(5, 1); increases size by 5 and initializes the new elements to 1
			swap(vector2)
				set1.swap(set2); swaps contents of set1 with set2

		holds a sequence of values, or elements
		stores its elements in contiguous memory locations
		you can use array subscript operator [] to read individual elements in the vector
			cannot use it to access element that does not yet exist

		Advantages over arrays:
			You don't have to declare the number of elements it will have
			If you add a value to a vector that's already full, it will automatically increase size
			Vectors can report the number of elements they contain

Searching and Sorting Arrays
	Linear Search
		Also called Sequential Search
		Searches the array from beginning to end
		Simple, but inefficient
	Binary Search
		Array must be sorted first
		Same as GuessTheNumber game
	Bubble Sort
		inefficient for large arrays
		void bubbleSort(int arr[],int size){ 
		   bool swap; int temp; 
		   do{ 
		      swap = false; 
		      for (int i = 0; i < (size - 1); i++) { 
		         if (arr[i] > arr[i + 1]) { 
		             temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; swap = true;
		         } 
		      } 
		   } while (swap); 
		}

	Selection Sort
		more efficient for larger arrays
		void selectionSort(int arr[],int size) { 
	       int start, minIndex, minVal; 
	       for (start = 0; start < (size âˆ’ 1); start++) { 
	           minIndex = start; minVal = arr[start]; 
	           for(int i = start + 1; i < size; i++) { 
	               if (arr[i] < minVal) { 
	                   minVal = arr[i]; 
	                   minIndex = i; 
	               } 
	           } 
	           arr[minIndex] = arr[start]; arr[start] = minVal; 
	       } 
	    } 

Pointers
	Getting the address of a variable
		char: 1 byte
		short: 2 bytes
		int, long, float: 4 bytes
		double: 8 bytes
	A variables address is the address of first byte allocated to it
		example: int num = 25; &num = address of num, in hexadecimal
	Do not confuse with reference variables

	Pointer Variables, or just pointers
		designed to hold memory addresses
		indirectly manipulate data stored in other variables

	Defining pointer variables:
		int *ptr;	int means it can hold the address of an int variable
			the above means "ptr is a pointer to an int"
			could also be written as int* ptr; to make it clear that it's a pointer rather than int

		Always define pointer by initializing with valid memory address
			nullptr - points to address 0
				int *ptr = nullptr;
					with older, non-C++11-compliant compilers, use 0 or NULL

		* is an indirection operator. It dereferences the pointer
			You are working, not with the pointer variable itself, but with the item it points to

		an array name is really a pointer to the first address of the array
			arr[i] == *(arr + i)

		Cannot multiply or divide pointers. Can only use +, -, ++, --

	Only use pointers with delete that were previously used with new

	Dynamic Memory Allocation
		if int *iptr = nullptr;
			then iptr = new int; tells computer to allocate enough memory for new int variable.
			 then you could say *iptr = 25;

		Dynamically Allocate an Array - pr9-14 or p524
			iptr = new int[100];
				for (int i = 0; i < 100; i++) { iptr[i] = 1; }
			Dynamically allocated memory should be released when a program is done with it
				to prevent Memory Leaks
				
				delete
					example: delete iptr;
						for arrays - delete [] iptr;

						example:
							void grabMemory(){const int SIZE = 100; int *iptr = new int[SIZE];}
								above function ends without deleting memory, so the memory sits
									in that function unused.
					Only use delete on pointers that were previously used with new

		Returning Pointers from Functions = pr9-15 or p526
			Make sure the pointer reference still exists
			You should return a pointer from a function only if it is:
				A pointer to an item that was passed into the function as an argument
					or A pointer to a dynamically allocated chunk of memory 
				
				example: char *findNull(char *str) {
							char *ptr = str;
							while (*ptr != '\0') {ptr++;}
							return ptr;
						 }

	Smart Pointers - automatically deletes memory when it's done with item
		introduced in C++11

		#include <memory>
			unique_ptr	-	pr9-17 or p534
				unique_ptr<int> ptr(new int);
			shared_ptr
			weak_ptr

			pr9-19 or p538-541:
				arrSelectSort
				showArrPtr
				showArray

Character Testing
	#include <cctype>
	returns true (nonzero) or false (0):
		isalpha(char) - letter of alphabet
		isalnum(char) - alphabet or digit (0-9)
		isdigit(char) - 0-9
		islower(char) - lowercase
		isupper(char) - uppercase
		isprint(char) - printable character (including space)
		ispunct(char) - printable character other than digit, letter, or space
		isspace(char) - whitespace - space '', newline '\n', vertical tab '\v', tab '\t'

C-Strings
	#include <cstring>

	 strlen(str) - length of char array minus null terminator

	 strcat(str1, str2) - concatenate 2 strings
	 strcpy(charArr, "") - copy a string to a char array
	 	Safer to use strncat and strncpy:
	 	strncat(str1, str2, int) - int is max number of str2 chars to append to str1
	 	strncpy(str1, str2, int) - int is max number of str2 chars to copy to str1

	 strstr(charArr, "") - search for some string inside a char array
	 strcmp(char *str1, char *str2)
	 	returns zero if equal
	 	returns negative if str1 comes BEFORE str2 alphabetically
	 	returns positive if str1 comes AFTER str2 alphabetically

	 Numeric Conversion Functions

	 	atoi("12345") - converts C-string to integer
	 	atol("9999999") - converts C-string to long integer
	 	atof("12.345") - converts C-string to double, can use as float

	 	to_string(num) - converts number to string

Structured Data
	struct
		struct Tag {}; Remember the semicolon
			capitalize first letter of name (tag)

		Initialization List - example:
			struct City {string name; string state;};
				City city = {"Dallas", "TX"};

		Dereference a struct variable with -> instead of *
			example:
				Circle *cirPtr = nullptr; cirPtr = new Circle; cirPtr->radius = 10;

	Union
		union Tag {};
			union {}; - Anonymous union
		Like a structure, but all members occup the same memory area
			So only one member can be used at a time
				They conserve memory

		If global, must be declared static.
			static union Tag {};

	Enumerated Data Type
		enum Name {ONE, TWO, THREE, FOUR};
			or enum Water {FREEZING = 32, BOILING = 212}; 	to assign values explicitly
			or enum Car {FORD, CHEVY, JEEP} someCar, anotherCar; 	to define variables at same time
				notice there's no semicolon until after variables
			
		static_cast<Name>(ONE+1); to use enums like regular ints

		Must be unique within same scope unless strongly typed:
			Strongly Typed enums:
				enum class Name {ONE, TWO, THREE};
				enum class Name2 {TWO, FOUR, SIX}
					CAN use same enum names within scope
						Name name = Name::TWO;
						Name2 bob = Name2::TWO;

							static_cast<int>(Name::TWO) to retrieve underlying integer value

		

