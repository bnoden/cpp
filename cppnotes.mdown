C++ Notes

Files:
	ofstream - output file stream
		ofstream outputFile("file.txt");
		outputFile << "Write to file just like cout";
	ifstream - input files stream
		ifstream inputFile;
			inputFile.open("file.txt");
			inputFile.open("C:\\data\\file.txt"); - extra backslash to represent string literal backslash
			inputFile.close();
			inputFile >> someString; - reads string from next read position, each string seperated by whitespace (space or newline)
			int value; inFile >> value; - converts number in file from string to number
			while (inFile >> value) - read to end of file
			if (inFile) {something} else {error} - test for file open errors
				if (infile.fail()) {error} else {something} - alternative to above
	fstream - file stream - create, write, and read from files
		ios
			example: someFile.open("whatever.txt", io::in); - input mode
					 someFile.open("whatever.txt", io::out); - output mode

			ios::app - Append mode. All output is appended (added to the end) to the file.
				creates file if it doesn't exist
			ios::ate - At The End. Goes directly to end of file. Output may be written anywhere in file.
			ios::binary - Binary Mode. Data are written to or read from file in binary format.
			ios::in - Input Mode. Data read from file. File created if none exists.
			ios::out - Output mode. Data written to file. Contents deleted if it already exists.
			ios::trunc Deletes (truncates) contents if file exists.

			Error Testing - pr12-6 or p668
				ios::eofbit - end of input stream is encountered
					eof() - returns true (nonzero) if eofbit flag is set, else false

				ios::failbit - attempted operation failed
				ios::hardfail - unrecoverable error occurred
					fail() - returns true (nonzero) if failbit or hardfailbit are set, else false

				ios::badbit - invalid operation has been attempted

				ios::goodbit - none of the above; good condition
					good() - returns true (nonzero) if goodbit is set, else false

					clear() - clears all above flags if no arguments
						or call with specific flag as argument

					example:
						void showState(fstream &file)  { 
						   cout << "File Status:\n"; 
						   cout << " eof bit: " << file.eof() << endl; 
						   cout << " fail bit: " << file.fail() << endl; 
						   cout << " bad bit: " << file.bad() << endl; 
						   cout << " good bit: " << file.good() << endl; 
						   file.clear();     // Clear any bad bits 
						}

			combine with | 		pr12-20, pr12-21, 12-22 or p698, p699, p700
				example: someFile.open("whatever.txt", ios::in | ios::out);
						- write to and read from file, and contents are preserved

		<EOF> - end-of-file marker

		Use same formatting tools as with cout, such as setprecision(), fixed, etc.

	Passing File Stream Objects to Functions - pr12.3 or p666

	getline(dataFile, str, '\n');
		reads from dataFile, stores to str, stops reading if it encounters \n
			\n is default delimiter, but you can use anything

	get Member Function - pr12-10 or p675
		inFile.get(ch);

	put Member Function - pr12-11 or p676
		outFile.put(ch);

	Work with multiple files
		ifstream file1, file2, file3; 

	Binary Files
		file.open("stuff.dat", ios::out | ios::binary);

		write and read Member Functions - pr12-13
			write
				fileObject.write(address, size);
					address is starting address of section of memory to be written to file
						expected to be char or pointer to char
					size is number of bytes to write, must be integer value
				char letter = 'A'; file.write(&letter, sizeof(letter));

				char data[] = {'A', 'B', 'C', 'D'}; file.write(data, sizeof(data));

			read
				fileObject.read(address, size);

				char letter; file.read(&letter, sizeof(letter));

				char data[4]; file.read(data, sizeof(data));

		Writing Data other than Char to Binary Files - pr12-14
			must use type cast
				reinterpret_cast - convert pointer from one type to another
					reinterpret_cast<dataType>(value)
						dataType is type converting to
						value is value you're converting

							example:
								int x = 65; char* ptr = nullptr; ptr = reinterpret_cast<char*>(&x);

		Creating Records with Structures - pr12-15, pr12-16 or p686, p687
			Structures may be used to store fixed-length records into a file
			Always use ios::binary mode when opening a file to store structures

		Random-Access Files - pr12-17, pr12-18 or p691, p692
			means nonsequentially accessing data in a file
				-think of a cd player as apposed to cassette

			seekp ("seek put") for output (put into file)
				file.seekp(20L, ios::beg);
					-moves files write position to byte number 20
						(bytes start at 20, so 21st byte)

			seekg ("seek get") for input (get out from file)

			tellp and tellg - pr12-19 or p694

				ios::beg - offest calculated from beginning of file
				ios::end - offest calculated from end of file
				ios::cur - offest calculated from current position

					negative offsets move backwards
						example: file.seekp(−10L, ios::end);
							-Sets the write position to the 10th byte from the end of the file. 

				Must use clear() before calling seekg or seekp if end-of-file has been read

			"rewind"
				dataFile.clear(); dataFile.seekg(0L, ios::beg);
					clear eliminates the need to close and reopen the file each time





C-strings - in older versions of C++
	strObject.c_str() - returns string stored in strObject as a null-terminated C-string
		Example: inFile.open(filename.c_str());

Reference variables as parameters
	example: timesTwo(int &num) { num*=2; }
		if int num = 4, then method(num) == 8

Two or more functions may have the same name, as long as their parameter lists are different.
	example: int square(int); double square(double);
	example: int square(int); int square(int, int); int square(int, double);

Range-based for loop:
	example - int numbers[] = {3,6,9};
				for (int val : numbers) { cout << val << endl; }

STL (Standard Template Library)
	data types defined in STL commonly called containers, because they store and organize data
		2 types
			sequence containers
				organizes data in a sequential fashion, similar to an array
			associative containers
				organizes data with keys, which allow rapid, random access to elements stored in container

	STL vector
		#include <vector> (must have using namespace std;)
			vector<int> numbers;
			vector<int> numbers(10); to define starting size
			vector<int> numbers(10, 2); to define starting size of 10, each element initialized to 2
			vector<int> set2(set1); initializes set2 by copying set 1 to it
			vector<int> numbers { 10, 20, 30, 40 }; initializes vector with list of values
				no need for equals sign like array: int numbers[] = { 10, 20, 30, 40 };
				numbers[i] can be replaced with new value
			Rang-based for loops is same as array:
				vector<int> numbers { 3, 6, 9};
					for (int val : numbers) { cout << val << endl; }
			push_back
				numbers.push_back(25); puts 26 in last element, or adds as new element if full
			pop_back
				numbers.pop_back(); removes the last element
			clear
				numbers.clear(); clears all elements
			empty
				if (numbers.empty()) determines if vector is empty
			size
				x = numbers.size(); x = size of vector
			at
				x = numbers.at(5); x = the value of the 6th element (an array would be numbers[5])
			reverse
				numbers.reverse(); reverses the order of elements
			resize(elements, value)
				numbers.resize(5, 1); increases size by 5 and initializes the new elements to 1
			swap(vector2)
				set1.swap(set2); swaps contents of set1 with set2

		holds a sequence of values, or elements
		stores its elements in contiguous memory locations
		you can use array subscript operator [] to read individual elements in the vector
			cannot use it to access element that does not yet exist

		Advantages over arrays:
			You don't have to declare the number of elements it will have
			If you add a value to a vector that's already full, it will automatically increase size
			Vectors can report the number of elements they contain

Searching and Sorting Arrays
	Linear Search
		Also called Sequential Search
		Searches the array from beginning to end
		Simple, but inefficient
	Binary Search
		Array must be sorted first
		Same as GuessTheNumber game
	Bubble Sort
		inefficient for large arrays
		void bubbleSort(int arr[],int size){ 
		   bool swap; int temp; 
		   do{ 
		      swap = false; 
		      for (int i = 0; i < (size - 1); i++) { 
		         if (arr[i] > arr[i + 1]) { 
		             temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; swap = true;
		         } 
		      } 
		   } while (swap); 
		}

	Selection Sort
		more efficient for larger arrays
		void selectionSort(int arr[],int size) { 
	       int start, minIndex, minVal; 
	       for (start = 0; start < (size − 1); start++) { 
	           minIndex = start; minVal = arr[start]; 
	           for(int i = start + 1; i < size; i++) { 
	               if (arr[i] < minVal) { 
	                   minVal = arr[i]; 
	                   minIndex = i; 
	               } 
	           } 
	           arr[minIndex] = arr[start]; arr[start] = minVal; 
	       } 
	    } 

Pointers
	Getting the address of a variable
		char: 1 byte
		short: 2 bytes
		int, long, float: 4 bytes
		double: 8 bytes
	A variables address is the address of first byte allocated to it
		example: int num = 25; &num = address of num, in hexadecimal
	Do not confuse with reference variables

	Pointer Variables, or just pointers
		designed to hold memory addresses
		indirectly manipulate data stored in other variables

	Defining pointer variables:
		int *ptr;	int means it can hold the address of an int variable
			the above means "ptr is a pointer to an int"
			could also be written as int* ptr; to make it clear that it's a pointer rather than int

		Always define pointer by initializing with valid memory address
			nullptr - points to address 0
				int *ptr = nullptr;
					with older, non-C++11-compliant compilers, use 0 or NULL

		* is an indirection operator. It dereferences the pointer
			You are working, not with the pointer variable itself, but with the item it points to

		an array name is really a pointer to the first address of the array
			arr[i] == *(arr + i)

		Cannot multiply or divide pointers. Can only use +, -, ++, --

	Only use pointers with delete that were previously used with new

	Dynamic Memory Allocation
		if int *iptr = nullptr;
			then iptr = new int; tells computer to allocate enough memory for new int variable.
			 then you could say *iptr = 25;

		Dynamically Allocate an Array - pr9-14 or p524
			iptr = new int[100];
				for (int i = 0; i < 100; i++) { iptr[i] = 1; }
			Dynamically allocated memory should be released when a program is done with it
				to prevent Memory Leaks
				
				delete
					example: delete iptr;
						for arrays - delete [] iptr;

						example:
							void grabMemory(){const int SIZE = 100; int *iptr = new int[SIZE];}
								above function ends without deleting memory, so the memory sits
									in that function unused.
					Only use delete on pointers that were previously used with new

		Returning Pointers from Functions = pr9-15 or p526
			Make sure the pointer reference still exists
			You should return a pointer from a function only if it is:
				A pointer to an item that was passed into the function as an argument
					or A pointer to a dynamically allocated chunk of memory 
				
				example: char *findNull(char *str) {
							char *ptr = str;
							while (*ptr != '\0') {ptr++;}
							return ptr;
						 }

	Smart Pointers - automatically deletes memory when it's done with item
		introduced in C++11

		#include <memory>
			unique_ptr	-	pr9-17 or p534
				unique_ptr<int> ptr(new int);
			shared_ptr
			weak_ptr

			pr9-19 or p538-541:
				arrSelectSort
				showArrPtr
				showArray

Character Testing
	#include <cctype>
	returns true (nonzero) or false (0):
		isalpha(char) - letter of alphabet
		isalnum(char) - alphabet or digit (0-9)
		isdigit(char) - 0-9
		islower(char) - lowercase
		isupper(char) - uppercase
		isprint(char) - printable character (including space)
		ispunct(char) - printable character other than digit, letter, or space
		isspace(char) - whitespace - space '', newline '\n', vertical tab '\v', tab '\t'

C-Strings
	#include <cstring>

	 strlen(str) - length of char array minus null terminator

	 strcat(str1, str2) - concatenate 2 strings
	 strcpy(charArr, "") - copy a string to a char array
	 	Safer to use strncat and strncpy:
	 	strncat(str1, str2, int) - int is max number of str2 chars to append to str1
	 	strncpy(str1, str2, int) - int is max number of str2 chars to copy to str1

	 strstr(charArr, "") - search for some string inside a char array
	 strcmp(char *str1, char *str2)
	 	returns zero if equal
	 	returns negative if str1 comes BEFORE str2 alphabetically
	 	returns positive if str1 comes AFTER str2 alphabetically

	 Numeric Conversion Functions

	 	atoi("12345") - converts C-string to integer
	 	atol("9999999") - converts C-string to long integer
	 	atof("12.345") - converts C-string to double, can use as float

	 	to_string(num) - converts number to string

Structured Data
	struct
		struct Tag {}; Remember the semicolon
			capitalize first letter of name (tag)

		Initialization List - example:
			struct City {string name; string state;};
				City city = {"Dallas", "TX"};

		Dereference a struct variable with -> instead of *
			example:
				Circle *cirPtr = nullptr; cirPtr = new Circle; cirPtr->radius = 10;

	Union
		union Tag {};
			union {}; - Anonymous union
		Like a structure, but all members occup the same memory area
			So only one member can be used at a time
				They conserve memory

		If global, must be declared static.
			static union Tag {};

	Enumerated Data Type
		enum Name {ONE, TWO, THREE, FOUR};
			or enum Water {FREEZING = 32, BOILING = 212}; 	to assign values explicitly
			or enum Car {FORD, CHEVY, JEEP} someCar, anotherCar; 	to define variables at same time
				notice there's no semicolon until after variables
			
		static_cast<Name>(ONE+1); to use enums like regular ints

		Must be unique within same scope unless strongly typed:
			Strongly Typed enums:
				enum class Name {ONE, TWO, THREE};
				enum class Name2 {TWO, FOUR, SIX}
					CAN use same enum names within scope
						Name name = Name::TWO;
						Name2 bob = Name2::TWO;

					enum class Day : char { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY };
					enum class Water : unsigned { FREEZING = 32, BOILING = 212 };

						static_cast<int>(Name::TWO) to retrieve underlying integer value



